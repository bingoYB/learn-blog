# 排序

## 冒泡排序

冒泡排序（英语：Bubble sort）是一种简单的排序算法。由于在算法的执行过程中，较小的元素像是气泡般慢慢「浮」到数列的顶端，故叫做冒泡排序。

### 原理

它的工作原理是每次检查相邻两个元素，如果前面的元素与后面的元素满足给定的排序条件，就将相邻两个元素交换。当没有相邻的元素需要交换时，排序就完成了。

经过次 $i$ 次扫描后，数列的末尾 $i$ 项必然是最大的项，因此冒泡排序最多需要扫描$n-1$遍数组就能完成排序。

冒泡排序是一种**稳定的**排序算法。

### 时间复杂度

冒泡排序的平均时间复杂度为 $O(n^2)$。

### 实现

```js
function  bubble_sort(nums) {
  let flag = true
  while (flag){
    flag = false
    for (let i = 0; i < nums.length-1; i++) {
      if(nums[i]>nums[i+1]){
        flag = true
        let temp = nums[i]
        nums[i] = nums[i + 1]
        nums[i + 1] = temp
      }
    }
  }
  return nums
}
```
### 外部链接

- [冒泡排序 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/冒泡排序)


## 选择排序

选择排序（英语：Selection sort）是排序算法的一种，它的工作原理是每次找出第 i 小的元素（也就是$A_{i...n}$中最小的元素），然后将这个元素与数组第 i 个位置上的元素交换。

### 原理

它的工作原理是每次检查相邻两个元素，如果前面的元素与后面的元素满足给定的排序条件，就将相邻两个元素交换。当没有相邻的元素需要交换时，排序就完成了。

经过 次扫描后，数列的末尾 项必然是最大的 项，因此冒泡排序最多需要扫描 遍数组就能完成排序。

由于 swap（交换两个元素）操作的存在，选择排序是一种不稳定的排序算法.

### 时间复杂度

选择排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为 $O(n^2)$。

### 实现

```js
function selection_sort(nums) {
  for (let i = 0; i < nums.length; i++) {
    let minIndex = i
    for (let j = i+1; j < nums.length; j++) {
      if(nums[j]<nums[minIndex]){
        minIndex = j
      }
    }
    let temp = nums[i]
    nums[i] = nums[minIndex]
    nums[minIndex] = temp
  }
  return nums
}
```
### 外部链接

- [选择排序 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/选择排序)


## 插入排序

插入排序（英语：Insertion sort）是一种简单直观的排序算法。它的工作原理为将待排列元素划分为“已排序”和“未排序”两部分，每次从“未排序的”元素中选择一个插入到“已排序的”元素中的正确位置。

一个与插入排序相同的操作是打扑克牌时，从牌桌上抓一张牌，按牌面大小插到手牌后，再抓下一张牌。

插入排序是一种稳定的排序算法。

### 时间复杂度
插入排序的最优时间复杂度为 $O(n)$ ，在数列几乎有序时效率很高。

插入排序的最坏时间复杂度和平均时间复杂度都为 $O(n^2)$ 。

### 实现

```js
function insertion_sort(nums) {
  for (let i = 1; i < nums.length; ++i) {
    let key = nums[i];
    let j = i - 1;
    // 遍历前面部分
    while (j >= 0 && nums[j] > key) {
      // 往后移1位
      nums[j + 1] = nums[j];
      --j;
    }
    nums[j + 1] = key;
  }
  return nums
}
```
### 外部链接

- [插入排序 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/插入排序)


## 计数排序

计数排序（英语：Counting sort）是一种线性时间的排序算法。不需要进行比较.

### 原理

计数排序的工作原理是使用一个额外的数组 $C$，其中第 $i$个元素是待排序数组 $A$ 中值等于 $i$的元素的个数，然后根据数组 $C$来将 $A$ 中的元素排到正确的位置

它的工作过程分为两个步骤：

- 计算每个数出现了几次；
- 直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次。

计数排序是一种稳定的排序算法。

### 时间复杂度

计数排序的时间复杂度为 $O(n+w)$，其中 $w$ 代表待排序数据的值域大小.

它**适用于一定范围的整数排序**。**在取值范围不是很大的情况下，它的性能在某些情况甚至快过那些O(nlogn)的排序，例如快速排序、归并排序。**


### 实现

```js
function counting_sort(nums) {
  let countArr = []
  let result =[]
  // 统计数字出现的次数
  for (let i = 0; i < nums.length; ++i) {
    countArr[nums[i]] ? countArr[nums[i]]++ : countArr[nums[i]]=1
  }
  // 根据计数进行排序
  for (let i = 0; i < countArr.length; ++i) {
    while (countArr[i]) {
      result.push(i)
      countArr[i]--
    }
  }
  return result
}
```
### 外部链接

- [计数排序 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/计数排序)

## 快速排序

快速排序（英语：Quicksort），又称分区交换排序（英语：partition-exchange sort），简称快排，是一种被广泛运用的排序算法。

本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。

### 原理

快速排序的工作原理是通过 分治 的方式来将一个数组排序。

快速排序分为三个过程：

1. 将数列划分为两部分（要求保证相对大小关系）；
2. 递归到两个子序列中分别进行快速排序；
3. 不用合并，因为此时数列已经完全有序。

和归并排序不同，第一步并不是直接分成前后两个序列，而是在分的过程中要保证相对大小关系。具体来说，第一步要是要把数列分成两个部分，然后保证前一个子数列中的数都小于后一个子数列中的数。为了保证平均时间复杂度，一般是随机选择一个数 来当做两个子数列的分界。

之后，维护一前一后两个指针 和 ，依次考虑当前的数是否放在了应该放的位置（前还是后）。如果当前的数没放对，比如说如果后面的指针 遇到了一个比 小的数，那么可以交换 和 位置上的数，再把 向后移一位。当前的数的位置全放对后，再移动指针继续处理，直到两个指针相遇。

其实，快速排序没有指定应如何具体实现第一步，不论是选择 的过程还是划分的过程，都有不止一种实现方法。

第三步中的序列已经分别有序且第一个序列中的数都小于第二个数，所以直接拼接起来就好了。

### 时间复杂度

快速排序的最优时间复杂度和平均时间复杂度为$O(n\log n)$ ，最坏时间复杂度为 $O(n^2)$。

快速排序是一种不稳定的排序算法。

快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。

### 实现

```js
function quick_sort(nums) {
  if (nums.length<2) return nums
  let base = nums[0]
  let part1 = [],part2 = []
  for (let i = 1; i < nums.length; ++i) {
    if (nums[i] > base) part2.push(nums[i])
    else part1.push(nums[i])
  }
  part1 = quick_sort(part1)
  part2 = quick_sort(part2)
  return [...part1,base,...part2]
}
```

### 外部链接

- [快速排序 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/快速排序)

## 归并排序

归并排序（英语：merge sort）是一种采用了 [分治](https://oi-wiki.org/basic/divide-and-conquer/) 思想的排序算法。

### 原理

归并排序分为三个步骤：

1. 将数列划分为两部分；
2. 递归地分别对两个子序列进行归并排序；
3. 合并两个子序列。

不难发现，归并排序的前两步都很好实现，关键是如何合并两个子序列。注意到两个子序列在第二步中已经保证了都是有序的了，第三步中实际上是想要把两个 **有序** 的序列合并起来。

### 时间复杂度

归并排序是一种稳定的排序算法

归并排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为$O(n\log n)$ 。

归并排序的空间复杂度为 $O(n)$。

### 实现

```js
function merge_sort(nums,l,r) {
  if(r-l<1) return
  let mid = Math.floor((r+l)/2)
  // 分治
  merge_sort(nums,l,mid)
  merge_sort(nums,mid+1, r)
  // 临时数组
  let temp = []
  // 双指针
  let s = l,p=l,q = mid+1
  // 归并操作
  while(s<=r){
    if (p > mid || (q <= r && nums[p] > nums[q])) temp[s++] = nums[q++]
    else temp[s++] = nums[p++]
  }
  // 替换
  for (let i = l; i <= r; i++) {
    nums[i] = temp[i];
  }
  return nums
}

function sort(nums){
  return merge_sort(nums,0,nums.length-1)
}

```

### 外部链接

- [归并排序 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/归并排序)

