

# HTTP协议

> http 协议在哪一层

**ISO/OSI估计标准组织定义**：应用层 表示层 会话层 传输层  网络层 数据链路层 物理层

**TCP/IP**

应用层：为用户提供服务 http ftp dns smtp

传输层：为应用层实体提供端到端的通信功能，保证数据包的顺序传送及数据的完整性（TCP/UDP）

网络层：IP协议 解决主机到主机的通信问题

网络接口层（数据链路层 ：比特信号转成光信号/电信号；物理层）：监视数据在主机与网络间交换



### http工作过程

一次http操作称为一个事务  

1、客户端与服务器建立TCP连接

2、客户端发送请求给服务器

3、服务器接到请求给出响应

4、客户端收到信息展示到浏览器中，然后断开连接



### http缓存机制

强缓存与协商缓存



### 常用头字段



### 常见返回状态



### http1.1存在的问题



### HTTPS

#### 秘钥交换算法

1）Alice与Bob确定两个大素数n和g，这两个数不用保密 

（2）Alice选择另一个大随机数x，并计算A如下：A=gx mod n 

（3）Alice将A发给Bob

（4）Bob选择另一个大随机数y，并计算B如下：B=gy mod n 

（5）Bob将B发给Alice

（6）计算秘密密钥K1如下：K1=Bx mod n 

（7）计算秘密密钥K2如下：K2=Ay mod n K1=K2，因此Alice和Bob可以用其进行加解密



#### https加密过程

认证服务器。浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构，存在于浏览器的受信任CA机构列表中，并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。当然，我们可以管理这个受信任CA机构列表，添加我们想要信任的CA机构，或者移除我们不信任的CA机构。

协商会话密钥。客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。

加密通讯。此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。



https协议 SSL协议 TLS协议、握手协议的关系

https 基于ssl的http协议

SSL协议是一种记录协议，扩展性良好，可以方便添加子协议

握手协议是SSL的一个子协议

TLS是SSL的后续版本



#### TLS握手过程

1. ClientHello：客户端发送所支持的 SSL/TLS 最高协议版本号和所支持的加密算法集合及压缩方法集合等信息给 服务器端。
2. ServerHello：服务器端收到客户端信息后，选定双方都能够支持的 SSL/TLS 协议版本和加密方法及压缩方法， 返回给客户端。
3. SendCertificate（可选）：服务器端发送服务端证书给客户端。 
4.  RequestCertificate（可选）：如果选择双向验证，服务器端向客户端请求客户端证书
5.  ServerHelloDone：服务器端通知客户端初始协商结束。
6. ResponseCertificate（可选）：如果选择双向验证，客户端向服务器端发送客户端证书。 
7.  ClientKeyExchange：客户端使用服务器端的公钥，对客户端公钥和密钥种子进行加密，再发送给服务器端。
8. CertificateVerify（可选）：如果选择双向验证，客户端用本地私钥生成数字签名，并发送给服务器端，让其通 过收到的客户端公钥进行身份验证。
9. CreateSecretKey：通讯双方基于密钥种子等信息生成通讯密钥。 
10.  ChangeCipherSpec：客户端通知服务器端已将通讯方式切换到加密模式。 
11.  Finished：客户端做好加密通讯的准备。
12. ChangeCipherSpec：服务器端通知客户端已将通讯方式切换到加密模式。 
13.  Finished：服务器做好加密通讯的准备。
14. Encrypted/DecryptedData：双方使用客户端密钥，通过对称加密算法对通讯内容进行加密。 
15. ClosedConnection：通讯结束后，任何一方发出断开 SSL 连接的消息。





### HTTP2协议

#### 特点：

​	1、使用二进制格式传输，更高效，更紧凑；原本是用ASCII码进行传输，也就是纯文本，对于大的纯数字的时候，二进制格式占用容器更小

​	2、报头压缩，降低开销

​	3、多路复用，一个网络连接实现并行请求

​	4、服务器主动推送，减少请求的延迟

​	5、默认使用加密



#### **二进制分帧层**

HTTP2定义了如何封装HTTP消息在客户端与服务端的传输

在1.1之前的模型中，HTTP消息是一串文本，以换行符作为请求头请求体的分隔符，而HTTP2则对HTTP消息进行了封装，把头与数据分成了两个更小的二进制格式数据帧。这个”层“是位于套接字接口与应用的HTTP API之间的一个优化的新编码机制，所以对应用使用不影响。

#### **多路复用**：

在1.1中，客户端想要发起多个并行请求，必须使用多个TCP连接，这种模式会导致队首阻塞，降低连接效率。

HTTP2则将消息分解成一个一个的独立数据帧，交错发送，接收端再将帧重组成HTTP消息。

特点：1、交错发送多个请求，互不影响；2、并行交错发送多个响应，互不干扰；3、使用一个TCP连接发送多个请求和响应；4、消除不必要的延迟和提高现有网络容量的利用率；



#### **服务器推送**：

服务端可以对一个客户端请求发送多个响应。

**场景**：服务器已经知道客户端下一步要请求什么资源，这时候服务推送即可派上用场

推送资源可进行以下处理：

客户端缓存

不同页面复用

与其他资源复用

由服务端设定优先级

被客户端拒绝

服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。

一种解决办法是，只对第一次访问的用户开启服务器推送。下面是 Nginx 官方给出的示例，根据 Cookie 判断是否为第一次访问。

```yml

server {
    listen 443 ssl http2 default_server;

    ssl_certificate ssl/certificate.pem;
    ssl_certificate_key ssl/key.pem;

    root /var/www/html;
    http2_push_preload on;

    location = /demo.html {
        add_header Set-Cookie "session=1";
        add_header Link $resources;
    }
}


map $http_cookie $resources {
    "~*session=1" "";
    default "</style.css>; as=style; rel=preload";
}
```



#### **伪头字段**

http2内置了几个特殊的已“:”开始的key，用以替代HTTP/1.x中请求行/响应行的信息

```
:method  请求方法
:scheme 请求协议
:authority 请求域名
:path 请求地址

:status 响应状态

```

![image-20210317151643602](..\img\image-20210317151643602.png)



##### 存在的缺点（其实是tcp的缺点）

- tcp 以及tcp+tls建立连接延时，两个握手延时
- tcp队头阻塞：队头阻塞会导致 HTTP/2 在更容易丢包的弱网络环境下比 HTTP/1.1 更慢

##### http1.x存在的缺点

1.请求阻塞 如上已清晰说明

2.以明文文本字符串的形式传输内容，存在安全问题

3.http 请求头无状态特性 导致传输效率低下
多个http请求头大部分信息是相同的，重复传输，导致宽带浪费.请求头多达几百字节，而请求主体却只有十几个字节，有效信息比很低。

4.只能浏览器主动请求响应，不能服务器主动推送信息过来

### HTTP 3特点

- 减少了握手的延迟（1-RTT 或 0-RTT）
- 多路复用，并且没有 TCP 的阻塞问题
- 连接迁移，（主要是在客户端）当由 Wifi 转移到 4G 时，连接不会被断开

HTTP 3与HTTP 1.1和HTTP 2没有直接的关系，也不是http2的扩展

HTTP 3将会是一个全新的WEB协议

HTTP 3目前处于制订和测试阶段

https://www.chromium.org/quic





### HTTP与代理

![http3](../img/HTTP/http_proxy.png)

#### 正向代理

正向代理代理一般是指代理客户端，为客户端收发请求，使真实客户端对服务器不可见

#### 反向代理

反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见

#### 反向代理的用途

- 加密和SSL加速
- 负载均衡
- 缓存静态内容
- 压缩
- 减速上传
- 安全
- 外网发布

#### 反向代理做负载均衡

反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率;

![http3](../img/HTTP/proxy_1.png)