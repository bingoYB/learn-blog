<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TCP 协议 | BINGO BLOG</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/learn-blog/dist/logo.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css">
    <meta name="description" content="BINGO BLOG 学然后知不足 非淡泊无以明志，非宁静无以致远">
    <meta name="keywords" content="博客，前端，代码，个人博客，学习，兴趣，BINGOBLOG">
    
    <link rel="preload" href="/learn-blog/dist/assets/css/0.styles.4b1e8fc9.css" as="style"><link rel="preload" href="/learn-blog/dist/assets/js/app.7aeef9e3.js" as="script"><link rel="preload" href="/learn-blog/dist/assets/js/2.df75efdd.js" as="script"><link rel="preload" href="/learn-blog/dist/assets/js/6.87ba8884.js" as="script"><link rel="prefetch" href="/learn-blog/dist/assets/js/10.d1dc1021.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/11.9cc7e7f2.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/12.827e0248.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/13.1d6251e6.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/14.b9cca372.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/15.01f2c923.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/16.62c59df9.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/17.161b4da2.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/18.6666b93e.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/19.7134d2a4.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/20.8e07afce.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/21.385ba525.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/22.2f4e7f22.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/23.96d8a0e3.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/24.b9773e8c.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/25.75ac88a5.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/26.0caba4c3.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/27.1ebd477b.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/28.39b47510.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/29.76f052c9.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/3.379c5f12.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/30.950e7376.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/31.3c258a62.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/32.ca8496f8.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/33.f1f3745a.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/34.567d8d89.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/35.a4b8fca0.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/36.c044ac20.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/37.e5669e8d.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/38.aefd15f8.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/39.3cee7fc9.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/4.0f8a516d.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/40.8275784e.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/41.9b6c4113.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/42.ce97c57d.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/43.08c61eef.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/5.e88bedf3.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/7.de607b40.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/8.bea84309.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/9.25d86027.js">
    <link rel="stylesheet" href="/learn-blog/dist/assets/css/0.styles.4b1e8fc9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/learn-blog/dist/" class="home-link router-link-active"><img src="/learn-blog/dist/logo.png" alt="BINGO BLOG" class="logo"> <span class="site-name can-hide">BINGO BLOG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/learn-blog/dist/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/learn-blog/dist/algorithm/" class="nav-link">
  算法
</a></div> <a href="https://github.com/bingoYB/learn-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/learn-blog/dist/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/learn-blog/dist/algorithm/" class="nav-link">
  算法
</a></div> <a href="https://github.com/bingoYB/learn-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-blog/dist/note/css/CSS3笔记.html" class="sidebar-link">CSS3有哪些新特性？</a></li><li><a href="/learn-blog/dist/note/css/定位与布局.html" class="sidebar-link">定位与布局</a></li><li><a href="/learn-blog/dist/note/css/现代化CSS.html" class="sidebar-link">现代化css</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>编程思想</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-blog/dist/note/编程思想/IOC控制反转DI依赖注入.html" class="sidebar-link">IOC （Inverse of Control） 控制反转</a></li><li><a href="/learn-blog/dist/note/编程思想/SOLID设计原则.html" class="sidebar-link">SOLID设计原则</a></li><li><a href="/learn-blog/dist/note/编程思想/函数式编程.html" class="sidebar-link">函数式编程思想</a></li><li><a href="/learn-blog/dist/note/编程思想/面向切面编程.html" class="sidebar-link">面向切面编程（AOP）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-blog/dist/note/javascript/浏览器渲染机制.html" class="sidebar-link">浏览器工作原理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>HTTP</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-blog/dist/note/HTTP/DNS.html" class="sidebar-link">DNS</a></li><li><a href="/learn-blog/dist/note/HTTP/HTTP.html" class="sidebar-link">HTTP协议</a></li><li><a href="/learn-blog/dist/note/HTTP/RPC.html" class="sidebar-link">RPC</a></li><li><a href="/learn-blog/dist/note/HTTP/TCP协议.html" class="active sidebar-link">TCP 协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#模型详解" class="sidebar-link">模型详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#iso-标准" class="sidebar-link">iso 标准</a></li><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#流程" class="sidebar-link">流程</a></li><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#应用层" class="sidebar-link">应用层</a></li><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#传输层" class="sidebar-link">传输层</a></li><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#网络层" class="sidebar-link">网络层</a></li><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#数据链路层" class="sidebar-link">数据链路层</a></li><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#物理层" class="sidebar-link">物理层</a></li></ul></li><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#tcp-封装结构" class="sidebar-link">TCP 封装结构</a></li><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#三次握手-四次挥手" class="sidebar-link">三次握手 &amp; 四次挥手</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#三次握手" class="sidebar-link">三次握手</a></li><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#四次挥手" class="sidebar-link">四次挥手</a></li></ul></li><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#查看tcp连接状态" class="sidebar-link">查看TCP连接状态</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#重传、滑动窗口、流量控制、拥塞控制" class="sidebar-link">重传、滑动窗口、流量控制、拥塞控制</a></li><li class="sidebar-sub-header"><a href="/learn-blog/dist/note/HTTP/TCP协议.html#dns解析过程" class="sidebar-link">DNS解析过程</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Node</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-blog/dist/note/Node/Node事件循环.html" class="sidebar-link">Node事件循环</a></li><li><a href="/learn-blog/dist/note/Node/Node性能调优.html" class="sidebar-link">NodeJS 性能调优</a></li><li><a href="/learn-blog/dist/note/Node/PM2使用.html" class="sidebar-link">PM2</a></li><li><a href="/learn-blog/dist/note/Node/PM2工作机制.html" class="sidebar-link">PM2工作机制</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-blog/dist/note/React/源码（1）.html" class="sidebar-link">源码分析（1）</a></li><li><a href="/learn-blog/dist/note/React/源码（2）.html" class="sidebar-link">源码分析（2）</a></li><li><a href="/learn-blog/dist/note/React/源码（3）.html" class="sidebar-link">源码分析（3）</a></li><li><a href="/learn-blog/dist/note/React/源码（4）.html" class="sidebar-link">源码（4）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-blog/dist/note/webpack/webpack5新特性.html" class="sidebar-link">webpack5 新变化与对应的优化措施</a></li><li><a href="/learn-blog/dist/note/webpack/webpack打包优化之路.html" class="sidebar-link">Webpack | 优化 &amp; 插件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端图形学</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端工程化</span> <!----></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="tcp-协议"><a href="#tcp-协议" class="header-anchor">#</a> TCP 协议</h1> <h2 id="模型详解"><a href="#模型详解" class="header-anchor">#</a> 模型详解</h2> <h3 id="iso-标准"><a href="#iso-标准" class="header-anchor">#</a> iso 标准</h3> <p><img src="/learn-blog/dist/assets/img/tcp_model.d55b417c.png" alt="tcp_model"></p> <p><strong>iso标准</strong> 应用层、表示层和会话层合并为应用层。在TCP协议中为一层</p> <p>所以就为： 应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 数据链路层 -&gt; 物理层</p> <table><thead><tr><th>OSI中的层</th> <th>功能</th> <th>TCP/IP协议族</th></tr></thead> <tbody><tr><td>应用层</td> <td>文件传输,电子邮件,文件服务,虚拟在终端</td> <td>TFTP,HTTP,SNMP,FTP,SMTP,DNS,Telnet</td></tr> <tr><td>表示层</td> <td>数据格式化,代码转换,数据加密</td> <td>没有协议</td></tr> <tr><td>会话层</td> <td>解除或建立与接的节点的联系</td> <td>没有协议</td></tr> <tr><td>传输层</td> <td>提供端对端的接口</td> <td>TCP,UDP</td></tr> <tr><td>网络层</td> <td>为数据包选择路由</td> <td>IP,ICMP,RIP,OSPF,BGP,IGMP</td></tr> <tr><td>数据链路层</td> <td>传输有地址的帧一级错误检测功能</td> <td>SLIP,CSLIP,PPP,ARP,RARP,MTU</td></tr> <tr><td>物理层</td> <td>以二进制数据形式在屋里媒体上传输数据</td> <td>ISO2110,IEEE802,IEEE802.2</td></tr></tbody></table> <h3 id="流程"><a href="#流程" class="header-anchor">#</a> 流程</h3> <p>发起请求</p> <p>url -&gt; 添加请求头等包装 -&gt; tcp协议进行打包 -&gt; 继续打包</p> <p>接受请求</p> <p>逐条解压 ...-&gt; 只留数据</p> <h3 id="应用层"><a href="#应用层" class="header-anchor">#</a> 应用层</h3> <p>传输层之上，便是应用层。传输层的UDP报文和TCP报文段的数据部分就是应用层交付的数据，不同类型的网络应用有不同的通信规则，</p> <p>因此应用层协议是多种多样的，比如 DNS、FTP、Telnet、SMTP、HTTP、RIP、NFS 等协议都是用于解决其各自的一类问题。</p> <h3 id="传输层"><a href="#传输层" class="header-anchor">#</a> 传输层</h3> <p>网络接口：<strong>套接字</strong></p> <p><strong>TCP</strong>：</p> <ul><li>有连接:需要用端口号建立连接</li> <li>可靠传输:发送者能感知到是否发送成功</li> <li>面向字节流:字节流读取数据</li></ul> <p><strong>TCP最核心的机制</strong>：</p> <ul><li>可靠传输</li> <li>尽可能提高传输效率</li></ul> <p>可靠性传输 发送者能感知到失败(对比打电话和发短信)</p> <p>面向字节流，文件操作(I/O流)</p> <p><strong>UDP</strong>：</p> <ul><li>无连接: 知道对端的IP的端口号就可以直接传输,不需要建立连接</li> <li>不可靠: 没有确认机制,没有重传机制,如果因为网络故障该段无法发送到对端,UDP协议也不会给应用层返回任何错误信息</li> <li>面向数据报: 不能灵活的控制读写数据的次数和数量</li></ul> <h3 id="网络层"><a href="#网络层" class="header-anchor">#</a> 网络层</h3> <p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p> <p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所 起的作用就是在众多的选项内选择一条传输路线。</p> <p>网络接口：<strong>原始套接字</strong>(必须要提供权限)</p> <h3 id="数据链路层"><a href="#数据链路层" class="header-anchor">#</a> 数据链路层</h3> <p>处理设备连接</p> <p>详细资料请参考 <a href="https://www.jianshu.com/p/ffa5ec1c338d" target="_blank" rel="noopener noreferrer">TCP/IP--数据链路层<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="物理层"><a href="#物理层" class="header-anchor">#</a> 物理层</h3> <p>硬件相关</p> <h2 id="tcp-封装结构"><a href="#tcp-封装结构" class="header-anchor">#</a> TCP 封装结构</h2> <p><img src="/learn-blog/dist/assets/img/tcp_info.782aa750.png" alt="tcp_info"></p> <ol><li>端口，端口分发送端的端口（源端口source port） 和 接收端的端口（目的端口Destination port），为什么要这两个端口。因为要分辨这处理数据的进程是谁，只能通过端口去分辨进程。</li> <li>数据号Sequence Number，它是一个4字节的数据。TCP在给数据打包传送到下一层时不可能把所有的数据都打成一个大包，因为效率很低。它要把这个数据分成若干小包，逐个小包去进行分装，这些小包是有顺序的，这些数据就由数据号去体现。对方收到小包要组装，按照数据号来组装。这是为了减少重传的时候减少消耗，哪些失败了或者丢包了就重传哪个，不至于整个都重传。</li> <li>应答号Ackonwledgment Number，给对方的排序依据，上边的是给自己排序的依据。这样一来一回数据不会乱。这样就直接能对应上哪个编号的包失败了或者丢失了，就看应答号哪个没有对上。 后边还有一些偏移量Offset，标志位，滑动窗口，校验，处理指针，附加选项等等</li></ol> <h2 id="三次握手-四次挥手"><a href="#三次握手-四次挥手" class="header-anchor">#</a> 三次握手 &amp; 四次挥手</h2> <p><img src="/learn-blog/dist/assets/img/tcp_connection.6e32249b.png" alt="tcp_connection"></p> <h3 id="三次握手"><a href="#三次握手" class="header-anchor">#</a> 三次握手</h3> <p>建立连接时候的三次通信过程</p> <ol><li><p>客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SEND 状态。</p> <p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p></li> <li><p>服务器一开始是监听状态，收到包以后状态就变成了SYN_RCVD状态。服务器收到请求连接包以后它要发两个指令，发起连接指令和应答连接指令，合并在一起发过去。</p> <p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p> <blockquote><p>服务器会把SYN_RCVD状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>；</p> <p><strong>SYN攻击</strong>：SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p> <p>常见的防御 SYN 攻击的方法有如下几种：</p> <ul><li>缩短超时（SYN Timeout）时间</li> <li>增加最大半连接数</li> <li>过滤网关防护</li> <li>SYN cookies技术</li></ul></blockquote></li> <li><p>客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p> <p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></li></ol> <p><strong>三次握手原因：</strong></p> <p>第一次握手：客户端发送网络包，服务端收到了。</p> <p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p> <p>第二次握手：服务端发包，客户端收到了。</p> <p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p> <p>第三次握手：客户端发包，服务端收到了。</p> <p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p> <p><strong>ISN(Initial Sequence Number)</strong></p> <p>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p> <h3 id="四次挥手"><a href="#四次挥手" class="header-anchor">#</a> 四次挥手</h3> <p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</p> <p>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p> <p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p> <p>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p> <p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p> <p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p> <p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p> <p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p> <p><strong>2MSL等待状态</strong></p> <ul><li><p>保证客户端发送的最后一个ACK报文段能够到达服务端。</p> <p>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p></li> <li><p>防止“已失效的连接请求报文段”出现在本连接中。</p> <p>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p></li></ul> <h2 id="查看tcp连接状态"><a href="#查看tcp连接状态" class="header-anchor">#</a> 查看TCP连接状态</h2> <p>shell 中输入，命令更多参数参考 <a href="https://hondrytravis.github.io/docs/linux/linux#netstat" target="_blank" rel="noopener noreferrer">netstat<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Copy</p> <p>netstat -an</p> <p>会有一个state的状态值</p> <h5 id="tcp-和-udp-的区别和使用场景"><a href="#tcp-和-udp-的区别和使用场景" class="header-anchor">#</a> tcp 和 udp 的区别和使用场景？</h5> <p>1、基于连接与无连接；</p> <p>2、对系统资源的要求（TCP较多，UDP少）；</p> <p>3、UDP程序结构较简单；</p> <p>4、流模式与数据报模式 ；</p> <p>5、TCP保证数据正确性，UDP可能丢包；</p> <p>6、TCP保证数据顺序，UDP不保证。</p> <h3 id="重传、滑动窗口、流量控制、拥塞控制"><a href="#重传、滑动窗口、流量控制、拥塞控制" class="header-anchor">#</a> 重传、滑动窗口、流量控制、拥塞控制</h3> <p>TCP滑动窗口</p> <p>在TCP协议中，发送方和接受方通过各自维护自己的缓冲区。通过商定包的重传机制等一系列操作，来解决不可靠的问题。</p> <p>https://www.cnblogs.com/coder-programming/p/10627746.html</p> <p>https://www.jianshu.com/p/5b07a2f05771</p> <p><strong>拥塞窗口</strong>与<strong>发送窗口</strong></p> <p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个 的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p> <p>我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p> <p>拥塞窗口 cwnd 变化的规则：</p> <p>只要网络中没有出现拥塞，cwnd 就会增大；</p> <p>但网络中出现了拥塞，cwnd 就减少；</p> <p>慢启动-》拥塞避免-》拥塞发生-》快速恢复</p> <h3 id="dns解析过程"><a href="#dns解析过程" class="header-anchor">#</a> DNS解析过程</h3> <p>1、首先客户端位置是一台电脑或手机，在打开浏览器以后，比如输入<a href="https://link.zhihu.com/?target=http%3A//www.zdns.cn" target="_blank" rel="noopener noreferrer">http://www.zdns.cn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的域名，它首先是由浏览器发起一个DNS解析请求，如果本地缓存服务器中找不到结果，则首先会向根服务器查询，根服务器里面记录的都是各个顶级域所在的服务器的位置，当向根请求<a href="https://link.zhihu.com/?target=http%3A//www.zdns.cn" target="_blank" rel="noopener noreferrer">http://www.zdns.cn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的时候，根服务器就会返回.cn服务器的位置信息。</p> <p>2、递归服务器拿到.cn的权威服务器地址以后，就会寻问cn的权威服务器，知不知道<a href="https://link.zhihu.com/?target=http%3A//www.zdns.cn" target="_blank" rel="noopener noreferrer">http://www.zdns.cn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的位置。这个时候cn权威服务器查找并返回<a href="https://link.zhihu.com/?target=http%3A//zdns.cn" target="_blank" rel="noopener noreferrer">http://zdns.cn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>服务器的地址。</p> <p>3、继续向<a href="https://link.zhihu.com/?target=http%3A//zdns.cn" target="_blank" rel="noopener noreferrer">http://zdns.cn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的权威服务器去查询这个地址，由<a href="https://link.zhihu.com/?target=http%3A//zdns.cn" target="_blank" rel="noopener noreferrer">http://zdns.cn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的服务器给出了地址：202.173.11.10</p> <p>4、最终才能进行http的链接，顺利访问网站。</p> <p>5、这里补充说明，一旦递归服务器拿到解析记录以后，就会在本地进行缓存，如果下次客户端再请求本地的递归域名服务器相同域名的时候，就不会再这样一层一层查了，因为本地服务器里面已经有缓存了，这个时候就直接把<a href="https://link.zhihu.com/?target=http%3A//www.zdns.cn" target="_blank" rel="noopener noreferrer">http://www.zdns.cn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的A记录返回给客户端就可以了。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">5/7/2021, 2:27:56 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/learn-blog/dist/note/HTTP/RPC.html" class="prev">
        RPC
      </a></span> <span class="next"><a href="/learn-blog/dist/note/Node/Node事件循环.html">
        Node事件循环
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><section class="side-anchor"><ul style="display:none;"></ul></section></div></div>
    <script src="/learn-blog/dist/assets/js/app.7aeef9e3.js" defer></script><script src="/learn-blog/dist/assets/js/2.df75efdd.js" defer></script><script src="/learn-blog/dist/assets/js/6.87ba8884.js" defer></script>
  </body>
</html>
