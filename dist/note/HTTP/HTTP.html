<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP协议 | BINGO BLOG</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/learn-blog/dist/logo.png">meta
    <meta name="description" content="BINGO BLOG 学然后知不足 非淡泊无以明志，非宁静无以致远">
    
    <link rel="preload" href="/learn-blog/dist/assets/css/0.styles.2aea2f6c.css" as="style"><link rel="preload" href="/learn-blog/dist/assets/js/app.b211056b.js" as="script"><link rel="preload" href="/learn-blog/dist/assets/js/2.3f18bb02.js" as="script"><link rel="preload" href="/learn-blog/dist/assets/js/3.1a2db183.js" as="script"><link rel="prefetch" href="/learn-blog/dist/assets/js/10.da0b883c.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/11.dc8772c6.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/12.9e03ac91.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/13.34c78205.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/14.f063e69d.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/15.73d4cac0.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/16.f5316217.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/17.85e36966.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/18.2dad3fc6.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/19.7870dce9.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/20.823142e7.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/21.13f40157.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/22.8ab36a4e.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/23.32b6e87d.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/24.b1ab8c38.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/25.1bb04dbb.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/4.c653e12d.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/5.dcbc5fec.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/6.1a00d46c.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/7.2c73b84b.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/8.c5a211d7.js"><link rel="prefetch" href="/learn-blog/dist/assets/js/9.0ffe9c2b.js">
    <link rel="stylesheet" href="/learn-blog/dist/assets/css/0.styles.2aea2f6c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/learn-blog/dist/" class="home-link router-link-active"><img src="/learn-blog/dist/logo.png" alt="BINGO BLOG" class="logo"> <span class="site-name can-hide">BINGO BLOG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/learn-blog/dist/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/learn-blog/dist/algorithm/" class="nav-link">
  算法
</a></div> <a href="https://github.com/bingoYB/learn-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/learn-blog/dist/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/learn-blog/dist/algorithm/" class="nav-link">
  算法
</a></div> <a href="https://github.com/bingoYB/learn-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程思想</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>HTTP</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-blog/dist/note/HTTP/RPC.html" class="sidebar-link">RPC远程调用</a></li><li><a href="/learn-blog/dist/note/HTTP/HTTP.html" aria-current="page" class="active sidebar-link">HTTP协议</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/learn-blog/dist/note/HTTP/TCP协议.html" class="sidebar-link">TCP 协议</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http协议"><a href="#http协议" class="header-anchor">#</a> HTTP协议</h1> <blockquote><p>http 协议在哪一层</p></blockquote> <p><strong>ISO/OSI估计标准组织定义</strong>：应用层 表示层 会话层 传输层  网络层 数据链路层 物理层</p> <p><strong>TCP/IP</strong></p> <p>应用层：为用户提供服务 http ftp dns smtp</p> <p>传输层：为应用层实体提供端到端的通信功能，保证数据包的顺序传送及数据的完整性（TCP/UDP）</p> <p>网络层：IP协议 解决主机到主机的通信问题</p> <p>网络接口层（数据链路层 ：比特信号转成光信号/电信号；物理层）：监视数据在主机与网络间交换</p> <h3 id="http工作过程"><a href="#http工作过程" class="header-anchor">#</a> http工作过程</h3> <p>一次http操作称为一个事务</p> <p>1、客户端与服务器建立TCP连接</p> <p>2、客户端发送请求给服务器</p> <p>3、服务器接到请求给出响应</p> <p>4、客户端收到信息展示到浏览器中，然后断开连接</p> <h3 id="http缓存机制"><a href="#http缓存机制" class="header-anchor">#</a> http缓存机制</h3> <p>强缓存与协商缓存</p> <h3 id="常用头字段"><a href="#常用头字段" class="header-anchor">#</a> 常用头字段</h3> <h3 id="常见返回状态"><a href="#常见返回状态" class="header-anchor">#</a> 常见返回状态</h3> <h3 id="http1-1存在的问题"><a href="#http1-1存在的问题" class="header-anchor">#</a> http1.1存在的问题</h3> <h3 id="https"><a href="#https" class="header-anchor">#</a> HTTPS</h3> <h4 id="秘钥交换算法"><a href="#秘钥交换算法" class="header-anchor">#</a> 秘钥交换算法</h4> <p>1）Alice与Bob确定两个大素数n和g，这两个数不用保密</p> <p>（2）Alice选择另一个大随机数x，并计算A如下：A=gx mod n</p> <p>（3）Alice将A发给Bob</p> <p>（4）Bob选择另一个大随机数y，并计算B如下：B=gy mod n</p> <p>（5）Bob将B发给Alice</p> <p>（6）计算秘密密钥K1如下：K1=Bx mod n</p> <p>（7）计算秘密密钥K2如下：K2=Ay mod n K1=K2，因此Alice和Bob可以用其进行加解密</p> <h4 id="https加密过程"><a href="#https加密过程" class="header-anchor">#</a> https加密过程</h4> <p>认证服务器。浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构，存在于浏览器的受信任CA机构列表中，并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。当然，我们可以管理这个受信任CA机构列表，添加我们想要信任的CA机构，或者移除我们不信任的CA机构。</p> <p>协商会话密钥。客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。</p> <p>加密通讯。此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。</p> <p>https协议 SSL协议 TLS协议、握手协议的关系</p> <p>https 基于ssl的http协议</p> <p>SSL协议是一种记录协议，扩展性良好，可以方便添加子协议</p> <p>握手协议是SSL的一个子协议</p> <p>TLS是SSL的后续版本</p> <h4 id="tls握手过程"><a href="#tls握手过程" class="header-anchor">#</a> TLS握手过程</h4> <ol><li>ClientHello：客户端发送所支持的 SSL/TLS 最高协议版本号和所支持的加密算法集合及压缩方法集合等信息给 服务器端。</li> <li>ServerHello：服务器端收到客户端信息后，选定双方都能够支持的 SSL/TLS 协议版本和加密方法及压缩方法， 返回给客户端。</li> <li>SendCertificate（可选）：服务器端发送服务端证书给客户端。</li> <li>RequestCertificate（可选）：如果选择双向验证，服务器端向客户端请求客户端证书</li> <li>ServerHelloDone：服务器端通知客户端初始协商结束。</li> <li>ResponseCertificate（可选）：如果选择双向验证，客户端向服务器端发送客户端证书。</li> <li>ClientKeyExchange：客户端使用服务器端的公钥，对客户端公钥和密钥种子进行加密，再发送给服务器端。</li> <li>CertificateVerify（可选）：如果选择双向验证，客户端用本地私钥生成数字签名，并发送给服务器端，让其通 过收到的客户端公钥进行身份验证。</li> <li>CreateSecretKey：通讯双方基于密钥种子等信息生成通讯密钥。</li> <li>ChangeCipherSpec：客户端通知服务器端已将通讯方式切换到加密模式。</li> <li>Finished：客户端做好加密通讯的准备。</li> <li>ChangeCipherSpec：服务器端通知客户端已将通讯方式切换到加密模式。</li> <li>Finished：服务器做好加密通讯的准备。</li> <li>Encrypted/DecryptedData：双方使用客户端密钥，通过对称加密算法对通讯内容进行加密。</li> <li>ClosedConnection：通讯结束后，任何一方发出断开 SSL 连接的消息。</li></ol> <h3 id="http2协议"><a href="#http2协议" class="header-anchor">#</a> HTTP2协议</h3> <h4 id="特点"><a href="#特点" class="header-anchor">#</a> 特点：</h4> <p>​	1、使用二进制格式传输，更高效，更紧凑；原本是用ASCII码进行传输，也就是纯文本，对于大的纯数字的时候，二进制格式占用容器更小</p> <p>​	2、报头压缩，降低开销</p> <p>​	3、多路复用，一个网络连接实现并行请求</p> <p>​	4、服务器主动推送，减少请求的延迟</p> <p>​	5、默认使用加密</p> <h4 id="二进制分帧层"><a href="#二进制分帧层" class="header-anchor">#</a> <strong>二进制分帧层</strong></h4> <p>HTTP2定义了如何封装HTTP消息在客户端与服务端的传输</p> <p>在1.1之前的模型中，HTTP消息是一串文本，以换行符作为请求头请求体的分隔符，而HTTP2则对HTTP消息进行了封装，把头与数据分成了两个更小的二进制格式数据帧。这个”层“是位于套接字接口与应用的HTTP API之间的一个优化的新编码机制，所以对应用使用不影响。</p> <h4 id="多路复用"><a href="#多路复用" class="header-anchor">#</a> <strong>多路复用</strong>：</h4> <p>在1.1中，客户端想要发起多个并行请求，必须使用多个TCP连接，这种模式会导致队首阻塞，降低连接效率。</p> <p>HTTP2则将消息分解成一个一个的独立数据帧，交错发送，接收端再将帧重组成HTTP消息。</p> <p>特点：1、交错发送多个请求，互不影响；2、并行交错发送多个响应，互不干扰；3、使用一个TCP连接发送多个请求和响应；4、消除不必要的延迟和提高现有网络容量的利用率；</p> <h4 id="服务器推送"><a href="#服务器推送" class="header-anchor">#</a> <strong>服务器推送</strong>：</h4> <p>服务端可以对一个客户端请求发送多个响应。</p> <p><strong>场景</strong>：服务器已经知道客户端下一步要请求什么资源，这时候服务推送即可派上用场</p> <p>推送资源可进行以下处理：</p> <p>客户端缓存</p> <p>不同页面复用</p> <p>与其他资源复用</p> <p>由服务端设定优先级</p> <p>被客户端拒绝</p> <p>服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。</p> <p>一种解决办法是，只对第一次访问的用户开启服务器推送。下面是 Nginx 官方给出的示例，根据 Cookie 判断是否为第一次访问。</p> <div class="language-yml line-numbers-mode"><pre class="language-yml"><code>
server <span class="token punctuation">{</span>
    listen 443 ssl http2 default_server;

    ssl_certificate ssl/certificate.pem;
    ssl_certificate_key ssl/key.pem;

    root /var/www/html;
    http2_push_preload on;

    location = /demo.html <span class="token punctuation">{</span>
        add_header Set<span class="token punctuation">-</span>Cookie &quot;session=1&quot;;
        add_header Link $resources;
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


map $http_cookie $resources <span class="token punctuation">{</span>
    &quot;~<span class="token important">*session=1&quot;</span> &quot;&quot;;
    default &quot;&lt;/style.css<span class="token punctuation">&gt;</span>; as=style; rel=preload&quot;;
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h4 id="伪头字段"><a href="#伪头字段" class="header-anchor">#</a> <strong>伪头字段</strong></h4> <p>http2内置了几个特殊的已“:”开始的key，用以替代HTTP/1.x中请求行/响应行的信息</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>:method  请求方法
:scheme 请求协议
:authority 请求域名
:path 请求地址

:status 响应状态

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><img src="/learn-blog/dist/assets/img/image-20210317151643602.a2a99eac.png" alt="image-20210317151643602"></p> <h5 id="存在的缺点-其实是tcp的缺点"><a href="#存在的缺点-其实是tcp的缺点" class="header-anchor">#</a> 存在的缺点（其实是tcp的缺点）</h5> <ul><li>tcp 以及tcp+tls建立连接延时，两个握手延时</li> <li>tcp队头阻塞：队头阻塞会导致 HTTP/2 在更容易丢包的弱网络环境下比 HTTP/1.1 更慢</li></ul> <h5 id="http1-x存在的缺点"><a href="#http1-x存在的缺点" class="header-anchor">#</a> http1.x存在的缺点</h5> <p>1.请求阻塞 如上已清晰说明</p> <p>2.以明文文本字符串的形式传输内容，存在安全问题</p> <p>3.http 请求头无状态特性 导致传输效率低下
多个http请求头大部分信息是相同的，重复传输，导致宽带浪费.请求头多达几百字节，而请求主体却只有十几个字节，有效信息比很低。</p> <p>4.只能浏览器主动请求响应，不能服务器主动推送信息过来</p> <h3 id="http-3特点"><a href="#http-3特点" class="header-anchor">#</a> HTTP 3特点</h3> <ul><li>减少了握手的延迟（1-RTT 或 0-RTT）</li> <li>多路复用，并且没有 TCP 的阻塞问题</li> <li>连接迁移，（主要是在客户端）当由 Wifi 转移到 4G 时，连接不会被断开</li></ul> <p>HTTP 3与HTTP 1.1和HTTP 2没有直接的关系，也不是http2的扩展</p> <p>HTTP 3将会是一个全新的WEB协议</p> <p>HTTP 3目前处于制订和测试阶段</p> <p>https://www.chromium.org/quic</p> <h3 id="http与代理"><a href="#http与代理" class="header-anchor">#</a> HTTP与代理</h3> <p><img src="/learn-blog/dist/assets/img/http_proxy.9956d058.png" alt="http3"></p> <h4 id="正向代理"><a href="#正向代理" class="header-anchor">#</a> 正向代理</h4> <p>正向代理代理一般是指代理客户端，为客户端收发请求，使真实客户端对服务器不可见</p> <h4 id="反向代理"><a href="#反向代理" class="header-anchor">#</a> 反向代理</h4> <p>反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见</p> <h4 id="反向代理的用途"><a href="#反向代理的用途" class="header-anchor">#</a> 反向代理的用途</h4> <ul><li>加密和SSL加速</li> <li>负载均衡</li> <li>缓存静态内容</li> <li>压缩</li> <li>减速上传</li> <li>安全</li> <li>外网发布</li></ul> <h4 id="反向代理做负载均衡"><a href="#反向代理做负载均衡" class="header-anchor">#</a> 反向代理做负载均衡</h4> <p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率;</p> <p><img src="/learn-blog/dist/assets/img/proxy_1.14139fe8.png" alt="http3"></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">4/19/2021, 1:25:34 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/learn-blog/dist/note/HTTP/RPC.html" class="prev">
        RPC远程调用
      </a></span> <span class="next"><a href="/learn-blog/dist/note/HTTP/TCP协议.html">
        TCP 协议
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/learn-blog/dist/assets/js/app.b211056b.js" defer></script><script src="/learn-blog/dist/assets/js/2.3f18bb02.js" defer></script><script src="/learn-blog/dist/assets/js/3.1a2db183.js" defer></script>
  </body>
</html>
