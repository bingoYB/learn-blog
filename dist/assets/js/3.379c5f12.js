(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{384:function(e,t,s){e.exports=s.p+"assets/img/browser_structure8.70f6e1ea.png"},385:function(e,t,s){e.exports=s.p+"assets/img/browser_simple_workflow-2d0e702b575f29ec96473c91d08862b7.b03ab827.png"},386:function(e,t,s){e.exports=s.p+"assets/img/browser_workflow-08efb76c5a48fde5f0c40f3ff72624f1.5bfd3830.png"},387:function(e,t,s){e.exports=s.p+"assets/img/chrome_architecture-ffd69b40c3fc0372925b451d97c4ddac.77ee2836.png"},388:function(e,t,s){e.exports=s.p+"assets/img/chrome_renderer_prscess-1d9b9a1bb9d1743b4506e67f73e99f49.929e80d4.png"},389:function(e,t,s){e.exports=s.p+"assets/img/v2-71ef343b6a7b8ad7cf8aebbda44e77fd_720w.e0924b6b.jpg"},390:function(e,t,s){e.exports=s.p+"assets/img/v2-36ed368865ab9363706d57c66058b697_720w.0cc986eb.jpg"},391:function(e,t,s){e.exports=s.p+"assets/img/v2-ccaacbf35961ff61f30be90ac5b1be10_720w.eccd3a0f.jpg"},392:function(e,t,s){e.exports=s.p+"assets/img/v2-390e7945e6d578f61a96aadd14837c60_720w.aea2f1e8.jpg"},393:function(e,t,s){e.exports=s.p+"assets/img/v2-f256433f72ea22db26e4baa02cecac19_r.00e82292.jpg"},394:function(e,t,s){e.exports=s.p+"assets/img/v2-0e9c2c1761f084689a984a86866fc85d_720w.a1ba9e7f.jpg"},395:function(e,t,s){e.exports=s.p+"assets/img/v2-2fd68d4d3e0fff48d8a27d1ad72c7d65_720w.b1cb1863.jpg"},396:function(e,t,s){e.exports=s.p+"assets/img/render-tree-construction.0c389301.png"},397:function(e,t,s){e.exports=s.p+"assets/img/2014_05_04_02.2b170338.gif"},398:function(e,t,s){e.exports=s.p+"assets/img/bro5.09d8c607.png"},399:function(e,t,s){e.exports=s.p+"assets/img/bro4.cfd98577.png"},400:function(e,t,s){e.exports=s.p+"assets/img/bro1.c893e7e4.png"},401:function(e,t,s){e.exports=s.p+"assets/img/bro2.1def7a99.png"},402:function(e,t,s){e.exports=s.p+"assets/img/bro3.dc8b24ef.png"},448:function(e,t,s){"use strict";s.r(t);var r=s(19),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"浏览器工作原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器工作原理"}},[e._v("#")]),e._v(" 浏览器工作原理")]),e._v(" "),r("h3",{attrs:{id:"浏览器结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器结构"}},[e._v("#")]),e._v(" 浏览器结构")]),e._v(" "),r("p",[r("img",{attrs:{src:s(384),alt:"browser_structure"}})]),e._v(" "),r("ul",[r("li",[e._v("用户界面（User Interface）")]),e._v(" "),r("li",[e._v("浏览器引擎（Browser Engine）")]),e._v(" "),r("li",[e._v("渲染引擎（Rendering Engine）")]),e._v(" "),r("li",[e._v("网络（Networking）")]),e._v(" "),r("li",[e._v("XML解析器（XML Parser）")]),e._v(" "),r("li",[e._v("显示后端（Display Backend）")]),e._v(" "),r("li",[e._v("数据持久层（Data Persistence）")])]),e._v(" "),r("h3",{attrs:{id:"常见渲染引擎"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见渲染引擎"}},[e._v("#")]),e._v(" 常见渲染引擎")]),e._v(" "),r("p",[e._v("渲染引擎：能够能够将HTML/CSS/JavaScript文本及相应的资源文件转换成图像结果")]),e._v(" "),r("p",[e._v("渲染引擎的种类")]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",[e._v("渲染引擎")]),e._v(" "),r("th",[e._v("浏览器")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("Trident")]),e._v(" "),r("td",[e._v("IE、Edge(旧)")])]),e._v(" "),r("tr",[r("td",[e._v("Gecko")]),e._v(" "),r("td",[e._v("Firefox")])]),e._v(" "),r("tr",[r("td",[e._v("WebKit")]),e._v(" "),r("td",[e._v("Safari")])]),e._v(" "),r("tr",[r("td",[e._v("Blink(WebKit fork)")]),e._v(" "),r("td",[e._v("Chromium/Chrome，Opera，Edge(新)")])])])]),e._v(" "),r("h3",{attrs:{id:"工作流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#工作流程"}},[e._v("#")]),e._v(" 工作流程")]),e._v(" "),r("p",[e._v("简单流程")]),e._v(" "),r("p",[r("img",{attrs:{src:s(385),alt:"browser_simple_workflow"}})]),e._v(" "),r("p",[e._v("详细流程")]),e._v(" "),r("p",[r("img",{attrs:{src:s(386),alt:"browser_workflow"}})]),e._v(" "),r("h3",{attrs:{id:"浏览器的多进程架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的多进程架构"}},[e._v("#")]),e._v(" 浏览器的多进程架构")]),e._v(" "),r("p",[r("img",{attrs:{src:s(387),alt:"chrome_architecture"}})]),e._v(" "),r("p",[e._v("Browser：控制程序的“chrome”部分，包括地址栏，书签，后退和前进按钮。还处理Web浏览器的不可见的，和特权部分，例如网络请求和文件访问")]),e._v(" "),r("p",[e._v("Renderer：负责显示网站的选项卡内的所有内容")]),e._v(" "),r("p",[e._v("Plugin：控制网站使用的所有插件，例如flash")]),e._v(" "),r("p",[e._v("GPU：独立于其他进程的GPU处理任务。 它被分成多个不同的进程，因为GPU处理来自多个程序的请求并将它们绘制在同一个面中")]),e._v(" "),r("h3",{attrs:{id:"渲染进程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#渲染进程"}},[e._v("#")]),e._v(" 渲染进程")]),e._v(" "),r("p",[e._v("渲染器进程负责选项卡内发生的所有事情。 在渲染器进程中，主线程处理你为用户编写的大部分代码")]),e._v(" "),r("p",[e._v("如果你使用了web worker 或 service worker，有时JavaScript代码的一部分将由工作线程处理。 排版和栅格线程也在渲染器进程内运行，以便高效、流畅地呈现页面")]),e._v(" "),r("p",[r("img",{attrs:{src:s(388),alt:"chrome_renderer_prscess"}})]),e._v(" "),r("h4",{attrs:{id:"渲染过程-解析部分"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程-解析部分"}},[e._v("#")]),e._v(" 渲染过程 ：解析部分")]),e._v(" "),r("p",[r("img",{attrs:{src:s(389),alt:"img"}})]),e._v(" "),r("h5",{attrs:{id:"html解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#html解析"}},[e._v("#")]),e._v(" html解析")]),e._v(" "),r("p",[e._v("第一步（解析）：从网络或者磁盘下读取的HTML原始字节码，通过设置的charset编码，转换成相字符")]),e._v(" "),r("p",[r("img",{attrs:{src:s(390),alt:"img"}})]),e._v(" "),r("p",[e._v("第二步（token化）：通过词法分析器，将字符串解析成Token，Token中会标注出当前的Token是"),r("code",[e._v("开始标签")]),e._v("，还是"),r("code",[e._v("结束标签")]),e._v("，或者"),r("code",[e._v("文本标签")]),e._v("等。")]),e._v(" "),r("p",[r("img",{attrs:{src:s(391),alt:"img"}})]),e._v(" "),r("p",[e._v("第三步（生成Nodes并构建DOM树）：浏览器会根据Tokens里记录的"),r("code",[e._v("开始标签")]),e._v("，"),r("code",[e._v("结束标签")]),e._v("，将Tokens之间相互串联起来*（带有结束标签的Token不会生成Node）*。")]),e._v(" "),r("p",[e._v("Node包含了这个节点的所有属性。例如"),r("code",[e._v('<img src="xxx.png" >')]),e._v("标签最终生成出的节点对象中会保存图片地址等信息。\n事实上，在构建DOM树时，不是要等所有的Tokens都转换成Nodes后才开始，而是一边生成Token一边采取"),r("code",[e._v("深度遍历算法")]),e._v("消耗Token来生成Node，如下图所示：")]),e._v(" "),r("p",[e._v("图中有颜色的小数字代表构建的具体步骤，可以看出，首先生成出"),r("code",[e._v("html Token")]),e._v(",并消耗Token创建出"),r("code",[e._v("html 节点对象")]),e._v("，接着生成"),r("code",[e._v("head Token")]),e._v("并消耗Token创建出"),r("code",[e._v("head节点对象")]),e._v("......，当所有的Tokens都消耗完了，紧接着DOM树也就构建完了。")]),e._v(" "),r("p",[r("img",{attrs:{src:s(392),alt:"img"}})]),e._v(" "),r("blockquote",[r("p",[r("em",[e._v("1.词法分析是将字符流(char stream)转换为记号流(token stream)")])]),e._v(" "),r("p",[r("em",[e._v("2.语法分析成 AST (Abstract Syntax Tree) 在HTML中就构建DOM节点，生成DOM树")])])]),e._v(" "),r("h5",{attrs:{id:"子资源加载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#子资源加载"}},[e._v("#")]),e._v(" 子资源加载")]),e._v(" "),r("blockquote",[r("p",[e._v("注意JavaScript可以阻止解析")])]),e._v(" "),r("p",[e._v("在构建DOM树中遇到css资源、图片、script脚本资源时进行网络加载")]),e._v(" "),r("h5",{attrs:{id:"css解析-样式表计算"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css解析-样式表计算"}},[e._v("#")]),e._v(" css解析，样式表计算")]),e._v(" "),r("p",[e._v("DOM会记录页面的内容，但是浏览器还需要知道这些内容该用什么样式去展示，所以还需要构建CSSOMTree。CSSOM的生成过程和DOM的生成过程十分相似，也是：1.解析，2.Token化，3.生成Nodes并构建CSSOMTree：")]),e._v(" "),r("p",[e._v("假设浏览器收到了下面这样一段css:")]),e._v(" "),r("div",{staticClass:"language-css line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-css"}},[r("code",[r("span",{pre:!0,attrs:{class:"token selector"}},[e._v("body")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),r("span",{pre:!0,attrs:{class:"token property"}},[e._v("font-size")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 16px"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token selector"}},[e._v("p")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),r("span",{pre:!0,attrs:{class:"token property"}},[e._v("font-weight")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" bold"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token selector"}},[e._v("p span")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),r("span",{pre:!0,attrs:{class:"token property"}},[e._v("display")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("none"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token selector"}},[e._v("span")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),r("span",{pre:!0,attrs:{class:"token property"}},[e._v("color")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" red"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token selector"}},[e._v("img")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),r("span",{pre:!0,attrs:{class:"token property"}},[e._v("float")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" right"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br")])]),r("p",[e._v("最终会生成如下的CSSOMTree:")]),e._v(" "),r("p",[r("img",{attrs:{src:s(393),alt:"preview"}})]),e._v(" "),r("p",[e._v("官方对CSSOM构建给的一种解释：")]),e._v(" "),r("blockquote",[r("p",[e._v("未构建完的CSSOMTree是不准确的，浏览器必须等到CSSOMTree构建完毕后才能进入下一阶段。\n所以，CSS的加载速度与构建CSSOMTree的速度将直接影响首屏渲染速度，因此在默认情况下CSS被视为阻塞渲染的资源，需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。")])]),e._v(" "),r("p",[e._v("同理，JS也会可以修改CSS样式，影响CSSOMTree最终的结果。而我们前面提到，不完整的CSSOMTree是不可以被使用的，如果JS试图在"),r("strong",[e._v("浏览器还未完成CSSOMTree的下载和构建")]),e._v("时去操作CSS样式，浏览器会"),r("strong",[e._v("暂停脚本的运行和DOM的构建")]),e._v("，直至浏览器完成了CSSOM的下载和构建。也就是说，"),r("strong",[e._v("JS脚本的出现会让CSSOM的构建阻塞DOM的构建")]),e._v("。")]),e._v(" "),r("blockquote",[r("p",[e._v("平时谈及页面性能优化，经常会强调css文件应该放在html文档中的前面引入，js文件应该放在后面引入，这么做的原因是什么呢？")])]),e._v(" "),r("p",[e._v("如果JS放在前面，那么js执行时间与css执行时间会阻塞DOM树的构建")]),e._v(" "),r("p",[r("img",{attrs:{src:s(394),alt:"img"}})]),e._v(" "),r("p",[e._v("那如果我们把css放到前面，js放到最后引入时，构建时间会变成：")]),e._v(" "),r("p",[r("img",{attrs:{src:s(395),alt:"img"}})]),e._v(" "),r("h5",{attrs:{id:"布局-渲染-布局树构建"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#布局-渲染-布局树构建"}},[e._v("#")]),e._v(" 布局：渲染/布局树构建")]),e._v(" "),r("p",[e._v("DOM/CSSOM树本身并不能直接用于排版和渲染，浏览器还会生成另外一棵树：Render树。")]),e._v(" "),r("p",[e._v("将CSSOM应用到DOM树中每一个元素上，形成RenderTree")]),e._v(" "),r("p",[r("img",{attrs:{src:s(396),alt:"将 DOM 与 CSSOM 合并以形成渲染树"}})]),e._v(" "),r("ul",[r("li",[r("p",[e._v("Render 树上的每一个节点被称为："),r("code",[e._v("RenderObject")]),e._v("。")])]),e._v(" "),r("li",[r("p",[e._v("RenderObject跟 DOM 节点几乎是一一对应的，当一个"),r("code",[e._v("可见的 DOM 节点")]),e._v("被添加到 DOM 树上时，内核就会为它生成对应的 RenderOject 添加到 Render 树上。")])]),e._v(" "),r("li",[r("p",[e._v("其中，可见的DOM节点不包括：")]),e._v(" "),r("ul",[r("li",[e._v("一些不会体现在渲染输出中的节点（"),r("code",[e._v("<html><script><link>….")]),e._v("），会直接被忽略掉。")]),e._v(" "),r("li",[e._v("通过CSS隐藏的节点。例如上图中的"),r("code",[e._v("span")]),e._v("节点，因为有一个CSS显式规则在该节点上设置了"),r("code",[e._v("display:none")]),e._v("属性，那么它在生成RenderObject时会被直接忽略掉。")])])])]),e._v(" "),r("h5",{attrs:{id:"分层-layer图层树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分层-layer图层树"}},[e._v("#")]),e._v(" 分层：Layer图层树")]),e._v(" "),r("blockquote",[r("p",[e._v("浏览器渲染引擎并不是直接使用Render树进行绘制，为了方便处理"),r("strong",[e._v("Positioning,Clipping,Overflow-scroll,CSS Transfrom/Opacrity/Animation/Filter,Mask or Reflection,Z-index")]),e._v("等属性，浏览器需要生成另外一棵树："),r("strong",[e._v("Layer树 （ 层级树）")])])]),e._v(" "),r("p",[e._v("RenderLayer树是基于Render树建立起来的一颗新的树。同样，RenderLayer节点和Render节点不是一一对应关系，而是一对多的关系。")]),e._v(" "),r("p",[e._v("浏览器会为一些"),r("strong",[e._v("特定")]),e._v("的"),r("code",[e._v("RenderObject")]),e._v("生成对应的"),r("code",[e._v("RenderLayer")]),e._v("，其中的规则是：")]),e._v(" "),r("ul",[r("li",[e._v("是否是页面的根节点 document节点与html节点 "),r("em",[e._v("It’s the root object for the page")])]),e._v(" "),r("li",[e._v("是否有css的一些布局属性（relative absolute or a transform) "),r("em",[e._v("It has explicit CSS position properties (relative, absolute or a transform)")])]),e._v(" "),r("li",[e._v("是否透明 "),r("em",[e._v("It is transparent")])]),e._v(" "),r("li",[e._v("是否有溢出 "),r("em",[e._v("Has overflow, an alpha mask or reflection")])]),e._v(" "),r("li",[e._v("是否有css滤镜 "),r("em",[e._v("Has a CSS filter")])]),e._v(" "),r("li",[e._v("是否包含一个canvas元素使得节点拥有视图上下文 "),r("em",[e._v("Corresponds to canvas element that has a 3D (WebGL) context or an accelerated 2D context")])]),e._v(" "),r("li",[e._v("是否包含一个video元素 "),r("em",[e._v("Corresponds to a video element")])])]),e._v(" "),r("p",[e._v("为了直观了解这三种树，下图给出了这三种树及其它们之间的对应关系。")]),e._v(" "),r("img",{staticStyle:{zoom:"150%"},attrs:{src:s(397),alt:"img"}}),e._v(" "),r("h5",{attrs:{id:"paint-绘制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#paint-绘制"}},[e._v("#")]),e._v(" Paint 绘制")]),e._v(" "),r("p",[e._v("在绘制阶段，主线程会遍历布局树（layout tree），生成一系列的绘画记录（paint records）。并将其提交到合成线程。")]),e._v(" "),r("p",[r("img",{attrs:{src:s(398),alt:"image-20210322163500605"}})]),e._v(" "),r("h4",{attrs:{id:"渲染过程-合成部分"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程-合成部分"}},[e._v("#")]),e._v(" 渲染过程：合成部分")]),e._v(" "),r("h5",{attrs:{id:"分块、光栅化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分块、光栅化"}},[e._v("#")]),e._v(" 分块、光栅化")]),e._v(" "),r("p",[e._v("**光栅化：**把文档的结构、元素的样式、几何 形状和绘制顺序转换为屏幕上的像素称为光栅化，这个操作会提交到GPU进程进行工作")]),e._v(" "),r("p",[r("strong",[e._v("合成")]),e._v("是一种将页面的各个部分分层，分别栅格化，并在一个被称为合成器线程的独立线程中合成为页面的技术。")]),e._v(" "),r("p",[e._v("合成线程会根据视口viewport将图层(Layer) 切分为一块又一块的小图块（tiles），之后将这些小图块分别进行发送给一系列光栅线程（raster threads）进行光栅化，结束后光栅线程会将每个图块的光栅结果存在"),r("code",[e._v("GPU Process")]),e._v("的内存中。")]),e._v(" "),r("p",[e._v("为了优化显示体验，合成线程可以给不同的光栅线程赋予不同的优先级，将那些在视口中的或者视口附近的层先被光栅化。")]),e._v(" "),r("h5",{attrs:{id:"合成与显示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#合成与显示"}},[e._v("#")]),e._v(" 合成与显示")]),e._v(" "),r("p",[e._v("⼀旦所有图块都被光栅化， 合成线程就会⽣成⼀个绘制图块的命令⸺“DrawQuad” ， 然后将该命令通过IPC提交给浏览器进程。 浏览器进程⾥⾯有⼀个叫 viz 的组件， ⽤来接收合成线程发过来的 DrawQuad 命 令， 然后根据 DrawQuad 命令， 将其⻚⾯内容绘制到内存中， 最后再将内存显⽰在屏幕上。")]),e._v(" "),r("p",[r("img",{attrs:{src:s(399),alt:"image-20210322162906930"}})]),e._v(" "),r("h4",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),r("p",[e._v("渲染主线程")]),e._v(" "),r("ol",[r("li",[e._v("渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。")]),e._v(" "),r("li",[e._v("渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets， 计算出 DOM 节点的样式。")]),e._v(" "),r("li",[e._v("创建布局树， 并计算元素的布局信息。")]),e._v(" "),r("li",[e._v("对布局树进⾏分层， 并⽣成分层树。")]),e._v(" "),r("li",[e._v("绘制（Paint）：为每个图层⽣成绘制列表， 并将其提交到合成线程。")])]),e._v(" "),r("p",[e._v("合成线程")]),e._v(" "),r("ol",[r("li",[e._v("合成线程将图层分成图块， 并在光栅化线程池中将图块转换成位图。")]),e._v(" "),r("li",[e._v("合成线程发送绘制图块命令 DrawQuad 给浏览器进程。")]),e._v(" "),r("li",[e._v("浏览器进程根据 DrawQuad 消息⽣成⻚⾯， 并显⽰到显⽰器上。")])]),e._v(" "),r("h3",{attrs:{id:"浏览器对事件的处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器对事件的处理"}},[e._v("#")]),e._v(" 浏览器对事件的处理")]),e._v(" "),r("p",[e._v("当页面渲染完毕以后，TAB内已经显示出了可交互的WEB页面，用户可以进行移动鼠标、点击页面等操作了，而当这些事件发生时候，浏览器是如何处理这些事件的呢？")]),e._v(" "),r("p",[e._v("以点击事件（click event）为例，让鼠标点击页面时候，首先接受到事件信息的是"),r("code",[e._v("Browser Process")]),e._v("，但是Browser Process只知道事件发生的类型和发生的位置，具体怎么对这个点击事件进行处理，还是由Tab内的"),r("code",[e._v("Renderer Process")]),e._v("进行的。Browser Process接受到事件后，随后便把事件的信息传递给了渲染进程，渲染进程会找到根据事件发生的坐标，找到目标对象（target），并且运行这个目标对象的点击事件绑定的监听函数（listener）。")]),e._v(" "),r("h3",{attrs:{id:"渲染进程中合成器线程接收事件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#渲染进程中合成器线程接收事件"}},[e._v("#")]),e._v(" 渲染进程中合成器线程接收事件")]),e._v(" "),r("p",[e._v("前面我们说到，合成器线程可以独立于主线程之外通过已光栅化的层创建组合帧，例如页面滚动，如果没有对页面滚动绑定相关的事件，组合器线程可以独立于主线程创建组合帧，如果页面绑定了页面滚动事件，合成器线程会等待主线程进行事件处理后才会创建组合帧。那么，合成器线程是如何判断出这个事件是否需要路由给主线程处理的呢？")]),e._v(" "),r("p",[e._v("由于执行 JS 是主线程的工作，当页面合成时，合成器线程会标记页面中绑定有事件处理器的区域为"),r("code",[e._v("非快速滚动区域")]),e._v("(non-fast scrollable region)，如果事件发生在这些存在标注的区域，合成器线程会把事件信息发送给主线程，等待主线程进行事件处理，如果事件不是发生在这些区域，合成器线程则会直接合成新的帧而不用等到主线程的响应。")]),e._v(" "),r("p",[r("img",{attrs:{src:s(400),alt:"非快速滚动区域有用户事件发生"}})]),e._v(" "),r("h3",{attrs:{id:"浏览器对事件的优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器对事件的优化"}},[e._v("#")]),e._v(" 浏览器对事件的优化")]),e._v(" "),r("p",[e._v("一般我们屏幕的帧率是每秒60帧，也就是60fps，但是某些事件触发的频率超过了这个数值，比如wheel，mousewheel，mousemove，pointermove，touchmove，这些连续性的事件一般每秒会触发60~120次，假如每一次触发事件都将事件发送到主线程处理，由于屏幕的刷新速率相对来说较低，这样使得主线程会触发过量的命中测试以及JS代码，使得性能有了没必要是损耗。")]),e._v(" "),r("p",[r("img",{attrs:{src:s(401),alt:"事件淹没了屏幕刷新的时间轴，导致页面很卡顿"}})]),e._v(" "),r("p",[e._v("出于优化的目的，浏览器会合并这些连续的事件，延迟到下一帧渲染是执行，也就是"),r("code",[e._v("requestAnimationFrame")]),e._v("之前。")]),e._v(" "),r("p",[r("img",{attrs:{src:s(402),alt:"和之前相同的事件轴，可是这次事件被合并并延迟调度了"}})]),e._v(" "),r("p",[e._v("而对于非连续性的事件，如keydown，keyup，mousedown，mouseup，touchstart，touchend等，会直接派发给主线程去执行。")]),e._v(" "),r("h3",{attrs:{id:"参考文章"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[e._v("#")]),e._v(" 参考文章")]),e._v(" "),r("p",[e._v("https://zhuanlan.zhihu.com/p/74792085")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://segmentfault.com/a/1190000022633988",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端都该懂的浏览器工作原理，你懂了吗？ - SegmentFault 思否"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://blog.csdn.net/ithzhang/article/details/7917754",target:"_blank",rel:"noopener noreferrer"}},[e._v("为什么浏览器会使用多进程架构"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.im/post/5e182a47e51d453cee48c752",target:"_blank",rel:"noopener noreferrer"}},[e._v("一文看懂Chrome浏览器工作原理"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/102128787",target:"_blank",rel:"noopener noreferrer"}},[e._v("浏览器多进程架构"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/47407398",target:"_blank",rel:"noopener noreferrer"}},[e._v("图解浏览器的基本工作原理"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://developers.google.com/web/updates/2018/09/inside-browser-part2",target:"_blank",rel:"noopener noreferrer"}},[e._v("Inside look at modern web browser (part 2)"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://developers.google.com/web/updates/2018/09/inside-browser-part3",target:"_blank",rel:"noopener noreferrer"}},[e._v("Inside look at modern web browser (part 3)"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);